<!DOCTYPE html>
<html>
<head>
    <title> loooooooo</title>
</head>
     
<body>
    <pre>





commands to run a Lex program:
gedit test.l # Open test.l file to write Lex code
lex test.l # Generate lex.yy.c from the Lex program
cc lex.yy.c -ll # Compile the C code generated by Lex
./a.out # Run the compiled program
key functions and variables in a Lex program:
1. yylex(): The main function for lexical analysis. It scans the input and
matches patterns defined in the Lex rules section. You call yylex() to
start the lexical analysis.
2. yywrap(): This function is called when yylex() reaches the end of the
input. By default, it returns 1 to indicate that no more input is available.
3. yytext: A global variable that holds the matched text from the input. After a
pattern matches, yytext contains the corresponding substring.
4. yyleng: A global variable that holds the length of the matched text (i.e., the
number of characters in yytext).
5. yyin, yyout, yywrap(): These variables control the input and output
streams in Lex. yyin specifies the input (default stdin), yyout specifies
the output (default stdout), and yywrap() handles the end of the input.
6. yyerror(): This function is used for error reporting when something goes
wrong in the lexical analysis process.
Ctrl D to signal the end of input (EOF) in the terminal, telling the Lex program to stop
reading input and start processing.
PART-I
1)Write a lex program to count following from a user entered string
a)Alphabet
b)Number


		% {
#include<stdio.h>
		int alpha=0;
		int num=0;
		%
	}
%%
[a-zA-Z] {alpha++;}
[0-9] {num++;}
. {;}
%%
int yywrap() {
	return 1;
}
void main() {
	printf("Enter input string followed by ctrl d\n");
	yylex();
	printf("Number of alphabets=%d\n",alpha);
	printf("Number of numbers=%d\n",num);
}
Output:
(base) student@NMAMIT-CSE-CSL06-PC-34:
~/Desktop/golibaje$ gedit test.l
(base) student@NMAMIT-CSE-CSL06-PC-34:
~/Desktop/golibaje$ lex test.l
(base) student@NMAMIT-CSE-CSL06-PC-34:
~/Desktop/golibaje$ cc lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-34:
~/Desktop/golibaje$ ./a.out
Enter input string followed by ctrl+d
dw2e
Number of alphabets=3
                    Number of numbers=1
                                      2)write a lex program to count the number of vowel and consonants in
a given alphabet string
% {
#include<stdio.h>
	int vowels=0;
	int cons=0;
	%
}
%%
[aeiouAEIOU] {vowels++;}
. {cons++;}
%%
int yywrap()
{
	return 1;
}
int main()
{
	printf("Enter the input alphabets string followed by Ctrl d\n");
	yylex();
	printf("No of vowels=%d\nNo of Consonants=%d\n",vowels,cons);
}
Output:
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ gedit pgm2.l
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ lex pgm2.l
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ cc lex.yy.c -ll
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ ./a.out
Enter the string..at end press Ctrl d
aexyz
No of vowels=2
             No of Consonants=3
                              3)write a lex program to check whether a given sentence is simple or
compound.
% {
#include<stdio.h>
	int is_Simple=1;
	%
}
%%
[ \t\n]+[Aa][Nn][Dd][ \t\n]+ {is_Simple=0;}
[ \t\n]+[Bb][Uu][Tt][ \t\n]+ {is_Simple=0;}
[ \t\n]+[Oo][Rr][ \t\n]+ {is_Simple=0;}
. {;}
%%
int yywrap()
{
	return 1;
}
void main()
{
	printf("Enter the sentence : at end press Ctrl d\n");
	yylex();
	if(is_Simple==0) {
		printf("\nSentence is Compound\n");
	}
	else {
		printf("\nSentence is Simple \n");
	}
}
Output:
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ gedit pgm3.l
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ lex pgm3.l
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ cc lex.yy.c -ll
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ ./a.out
Enter the sentence :
at end press Ctrl d
hello world
Sentence is Simple
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ ./a.out
Enter the sentence :
at end press Ctrl d
I want coffee and tea.
Sentence is Compound
4)write a lex program to count the number of characters,words,spaces and
lines in a given output file.
% {
#include<stdio.h>
	int wcount=0,ccount=0,scount=0,lcount=0;
	%
}
%%
[^\t\n,; \.: ]+ {wcount++; ccount=ccount+yyleng;}
[\n] {lcount++;}
[ ] {scount++;}
. {;}
%%
int yywrap()
{
	return 1;
}
void main(int argc,char *argv[])
{
	if(argc !=2) {
		printf("Enter command ./a.out filename :\n");
	}
	else {
		yyin=fopen(argv[1],"r");
		yylex();
		printf("Total words :%d\n Total characters :%d\n Total spaces :%d\n Total Lines
		       =%d\n",wcount,ccount,scount,lcount);
	}
}
ip.txt
this is line1
this is line2
this is line3
Output:
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ gedit pgm4.l
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ gedit ip.txt
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ lex pgm4.l
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ cc lex.yy.c -ll
golibaje@LAPTOP-FN4B2HHP:
~/t/cd$ ./a.out ip.txt
Total words :9
Total characters :33
Total spaces :6
Total Lines =3
             5)Write a lex program to count
i)the number of +ve and -ve integers
ii)the number of +ve and -ve fractions
gedit pgm5.l
% {
#include<stdio.h>
	int posint=0,negintt=0,posfract=0,negfract=0;
	%
}
%%
[+]?[0-9]+ {posint++;}
[-][0-9]+ {negintt++;}
[+]?[0-9]*[.][0-9]+ {posfract++;}
[-][0-9]*[.][0-9]+ {negfract++;}
[\n] {;}
. {;}
%%
int yywrap()
{
	return 1;
}
void main(int argc,char *argv[])
{
	if(argc !=2) {
		printf("Enter command ./a.out filename :\n");
	}
	else {
		yyin=fopen(argv[1],"r");
		yylex();
		printf("positive integers :%d\n Total negative integers :%d\n Total positive fraction :%d\n Total
		       negative fraction =%d\n",posint,negintt,posfract,negfract);
	}
}
Num.txt
125
+125
    +125.32
    0.52
    -125.32
    -1.2
    -125
    -34
    .52
    +.52
    Output:
    (base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje$ gedit pgm5.l
    (base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje$ lex pgm5.l
    (base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje$ cc lex.yy.c -ll
    (base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje$ ./a.out num.txt
    positive integers :2
    Total negative integers :2
    Total positive fraction :4
    Total negative fraction =1
                            






 6)Write a lex program to recognize and count the number of identifiers in
                             given input file :
                             gedit pgm6.l
                             % {
#include<stdio.h>
	int id=0;
	%
}
%%
^[a-zA-Z][a-zA-Z0-9]* {id++; printf("%s\n",yytext);}
[\n] {;}
.+ {;}
%%
int yywrap()
{
	return 1;
}
void main(int argc,char *argv[])
{
	if(argc !=2) {
		printf("Enter command ./a.out filename :\n");
	}
	else {
		printf("Valid identifiers are : \n");
		yyin=fopen(argv[1],"r");
		yylex();
		printf("Total valid Identifiers : %d\n",id);
	}
}
id.txt
ab123
a1b23
123abc
1a23b
a_bc123
x
Output :
(base) student@NMAMIT-CSE-CSL06-PC-22:
~/Desktop/golibaje$ gedit pgm6.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
~/Desktop/golibaje$ lex pgm6.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
~/Desktop/golibaje$ cc lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-22:
~/Desktop/golibaje$ ./a.out id.txt
Valid identifiers are :
ab123
a1b23
x
Total valid Identifiers : 3
7)Write a lex program to count the number of scanf and printf statements in
c program and replace them with readf and writef respectively.
gedit printf.l
% {
#include<stdio.h>
	int pc=0,sc=0;
	%
}
%%
"printf" {pc++; fprintf(yyout,"writef");}
"scanf" {sc++; fprintf(yyout,"readf");}
%%
int yywrap() {
	return 1;
}
void main(int argc,char *argv[])
{
	if(argc !=3) {
		printf("Enter command ./a.out ip_filename op_filename:\n");
	}
	else {
		yyin=fopen(argv[1],"r");
		yyout=fopen(argv[2],"w");
		yylex();
		printf("Total printf=%d\nTotal scanf=%d\n",pc,sc);
	}
}
gedit pgm7.c
% {
#include<stdio.h>
#include<stdlib.h>
	int main() {
		int n1, n2;
		printf("Enter number 1 : \n");
		scanf("%d",&n1);
		printf("Enter number 2:\n");
		scanf("%d",&n2);
		printf("n1=%d and n2=%d\n",n1,n2);
	}
output:
(base) student@NMAMIT-CSE-CSL06-PC-22:
	~/Desktop/golibaje$ gedit printf.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
	~/Desktop/golibaje$ lex printf.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
	~/Desktop/golibaje$ cc lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-22:
	~/Desktop/golibaje$ ./a.out pgm7.c out.c
	Total printf=3
	Total scanf=2
	out.c
	%{
#include<stdio.h>
#include<stdlib.h>
		int main() {
			int n1, n2;
			writef("Enter number 1 : \n");
			readf("%d",&n1);
			writef("Enter number 2:\n");
			readf("%d",&n2);
			writef("n1=%d and n2=%d\n",n1,n2);
		}
		8)Write a lex program to recognize valid arithmetic expression and identify
		the identifier and operator present,and print them separately.
		%{
#include<stdio.h>
			int nopnd=0,noprt=0,valid=1,top=-1;
			char str[20];
			char opnd[20][20],oprt[20][20];
			%
		}
		%%
		"(" {str[++top]='(';}
		")" {
			if(str[top]!='(') {
				valid=0;
				return;
			}
			else {
				top--;
			}
		}
		[0-9]+|[a-zA-Z][a-zA-Z0-9]* {strcpy(opnd[nopnd++],yytext);}
		"+"|"-"|"/"|"%"|"*" {strcpy(oprt[noprt++],yytext);}
		. {;}
		%%
		int yywrap()
		{
			return 1;
		}
		void main() {
			printf("Enter the expression \n");
			yylex();
			if(top==-1&& valid==1 && (nopnd-noprt)==1) {
				printf("Operands are :\n");
				for(int k=0; k<nopnd; k++) {
					printf("%s\n",opnd[k]);
				}
				printf("Operators are :\n");
				for(int k=0; k<noprt; k++) {
					printf("%s\n",oprt[k]);
				}
			}
			else {
				printf("Invalid Expression \n");
			}
		}
Output:
(warning:
 pgm8.l: In function b yylexb :
 pgm8.l:13:9: warning: b returnb  with no value, in function returning non-void
		                                13 | return;
		| ^~~~~~
lex.yy.c:619:21: note: declared here
		619 | #define YY_DECL int yylex (void)
		| ^~~~~
lex.yy.c:639:1: note: in expansion of macro b YY_DECLb 
		639 | YY_DECL
		| ^~~~~~~
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje$ lex pgm8.l
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje$ gedit pgm8.l
		^C
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje$ cc lex.yy.c -ll
pgm8.l: In function b yylexb :
pgm8.l:13:9: warning: b returnb  with no value, in function returning non-void
		                               13 | return;
		| ^~~~~~
lex.yy.c:619:21: note: declared here
		619 | #define YY_DECL int yylex (void)
		| ^~~~~
lex.yy.c:639:1: note: in expansion of macro b YY_DECLb 
		639 | YY_DECL
		| ^~~~~~~
		)
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje$ ./a.out
		Enter the expression
		(a+b*c)
Operands are :
		a
		b
		c
Operators are :
		+
		    *
    (base) student@NMAMIT-CSE-CSL06-PC-22:
		    ~/Desktop/golibaje$ ./a.out
		    Enter the expression
		    (q
		    Invalid Expression
    (base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje$ ./a.out
		    Enter the expression
		    (a+b+(b*c))
    Operands are :
		    a
		    b
		    b
		    c
    Operators are :
		    +
		    +
		    *
		    9) write a program to count the number of comment line in a given c program.also
		    eliminate them and copy that program to separate file.
		    %{
#include<stdio.h>
			int com=0;
			%
		}
		%s comment
		%%
		"//" {com++;}
		"/*" {BEGIN comment;}
		<comment>\n {com++;}
		<comment>. {;}
		<comment>"*/" {com++; BEGIN 0;}
		. {fprintf(yyout,"%s",yytext);}
		%%
		int yywrap()
		{
			return 1;
		}
		void main(int argc,char *argv[]) {
			if(argc !=3) {
				printf("Enter ./a.out input output \n");
			}
			else {
				yyin=fopen(argv[1],"r");
				yyout=fopen(argv[2],"w");
				yylex();
				printf("NUmber of comment lines =%d\n",com);
			}
		}
		(input file)
		/*A c program Example */
#include<stdio.h>
#include<stdlib.h>
		/* The program reads and displays two numbers
		*/
//
		int main() {
			int n1, n2;
			printf("Enter number 1 : \n");
			scanf("%d",&n1);
			printf("Enter number 2:\n");
			scanf("%d",&n2);
			printf("n1=%d and n2=%d\n",n1,n2);
		}
Output:
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje$ gedit pgm9.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje$ lex pgm9.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje$ cc lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje$ ./a.out pgm9.c out.c
		Number of comment lines =5
		                         Out.c
#include<stdio.h>
#include<stdlib.h>
		int main() {
			int n1, n2;
			printf("Enter number 1 : \n");
			scanf("%d",&n1);
			printf("Enter number 2:\n");
			scanf("%d",&n2);
			printf("n1=%d and n2=%d\n",n1,n2);
		}
		gedit pgm1.y # Edit the Yacc grammar file.
		gedit pgm1.l # Edit the Lex file.
		yacc -d pgm1.y # Generate Yacc parser code and header.
		lex pgm1.l # Generate Lex scanner code.
		cc y.tab.c lex.yy.c -ll # Compile and link Yacc and Lex files.
		./a.out # Run the executable.
Key Functions:
		1. yyparse(): Starts the parsing process by invoking the parser based on defined rules in
			the Yacc file.
			2. yyerror(): Handles syntax errors during parsing. It prints an error message and can
			exit the program.
			3. yywrap(): Indicates the end of input, typically used in Lex when reading multiple input
			streams.
Key Variables:
1. yylval:
			Stores the semantic value of the current token, passed from the lexer to the
			parser.
2. yytext:
			Holds the current matched text (token) from the input stream in Lex.
3. yydebug:
			Controls debug output. Set to 1 to enable debugging information.
4. yylineno:
			Stores the current line number in the input stream (used in Lex).
5. yyerrflag:
			An internal flag used for error recovery by Yacc.
Other Concepts:
b Precedence and Associativity:
			Define the priority and direction for operators (%left,
				        %right, %nonassoc).
				b Grammar Rules (%%): Defines the syntax of the language by mapping tokens to rules.
				b Semantic Values ($$, $1, $2): Used in grammar rules to refer to the result of a rule ($$)
				or its components ($n).
				PART-II
				1)Write a YACC program to recognize grammar (a^nb, n>=10)
				gedit pgm1.y
				%{
#include<stdio.h>
#include<stdlib.h> //for exit call
			%}
	%token A B NL
	%%
//stmt : A A A A A A A A A A B S NL {printf("String is valid \n");exit(0);} (wrong)
stmt :
	A A A A A A A A A A S B NL {printf("String is valid \n"); exit(0);} // Corrected line
		;
S :
		A S
		|
		;
		%%
		int yyerror(char *msg) {
			printf("String is invalid\n");
			exit(0);
		}
		void main() {
			printf("Enter the string \n");
			yyparse();
		}
		gedit pgm1.l
		%{
#include "y.tab.h"
			%
		}
		%%
		"a" {return A;}
		"b" {return B;}
		\n {return NL;}
		. {return yytext[0];}
		%%
Output:
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ gedit pgm1.y
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ gedit pgm1.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ yacc -d pgm1.y
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ lex pgm1.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ cc y.tab.c lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
		Enter the string
		aaaaaaaaaab
		String is valid
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
		Enter the string
		aab
		String is invalid
		If this warning occurs, add the following code in the C code section (the first part of the YACC
		        file):
			%{
#include<stdio.h>
#include<stdlib.h> // For exit call
// Declare the external functions yylex() and yyerror() used by the parser
			int yylex();
			int yyerror(char *msg);
			%}
		2))Write a YACC program to recognize grammar (a^nb^n, n>=0)
		gedit pgm2.y
		%{
#include<stdio.h>
#include<stdlib.h> //for exit call
			%}
		%token A B NL
		%%
stmt :
		S NL {printf("String is valid \n"); exit(0);}
		;
S :
		A S B
		|
		;
		%%
		int yyerror(char *msg) {
			printf("String is invalid\n");
			exit(0);
		}
		void main() {
			printf("Enter the string \n");
			yyparse();
		}
		gedit pgm2.l
		%{
#include "y.tab.h"
			%
		}
		%%
		"a" {return A;}
		"b" {return B;}
		\n {return NL;}
		. {return yytext[0];}
		%%
Output:
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ yacc -d pgm2.y
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ lex pgm2.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ cc y.tab.c lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
		Enter the string
		String is valid
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
		Enter the string
		ab
		String is valid
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
		Enter the string
		aabb
		String is valid
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
		Enter the string
		aaaab
		String is invalid
		3)Write a YACC program to recognize a valid variable with starts with
		a letter followed by any number of letters or digits.
		gedit pgm3.y
		%{
#include<stdio.h>
#include<stdlib.h> //for exit call
			%
		}
		%token letter digit NL
		%%
stmt :
		variable NL {printf("String is valid \n"); exit(0);}
		;
variable :
		letter alnum
		;
alnum :
		letter alnum
		|digit alnum
		|
		;
		%%
		int yyerror(char *msg) {
			printf("String is invalid\n");
			exit(0);
		}
		void main() {
			printf("Enter the string \n");
			yyparse();
		}
		gedit pgm3.l
		%{
#include "y.tab.h"
			%
		}
		%%
		[a-zA-Z] {return letter;}
		[0-9] {return digit;}
		\n {return NL;}
		. {return yytext[0];}
		%%
output:
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
		./a.out
		Enter the string
		ab
		String is valid
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
		./a.out
		Enter the string
		a1b2c3
		String is valid
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
		./a.out
		Enter the string
		a?bc
		String is invalid
		(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
		Enter the string
		22dd
		String is invalid
		4)Write a YACC program to recognize a valid declaration statement.
		gedit pgm4.y
		%{
#include<stdio.h>
#include<stdlib.h> //for exit call
			%
		}
		%token INT FLOAT CHAR SP SC ID CM NL
		%%
stmt :
		type SP varlist SC NL {printf("valid declaration\n"); exit(0);}
		;
type :
		INT |FLOAT|CHAR
varlist :
		ID CM varlist
		|ID SP CM SP varlist
		|ID
		;
		%%
		int yyerror(char *msg) {
			printf("Invalid declaration\n");
			exit(0);
		}
		void main() {
			printf("Enter the declaration : \n");
			yyparse();
		}
		gedit pgm4.l
		%{
#include "y.tab.h"
			%
		}
		%%
		" " {return SP;}
		";" {return SC;}
		"int" {return INT;}
		"char" {return CHAR;}
		"float" {return FLOAT;}
		[a-zA-Z][a-zA-Z0-9]* {return ID;}
		"," {return CM;}
		\n {return NL;}
		. {return yytext[0];}
		%%
Output:
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ yacc
		-d pgm4.y
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ lex
		pgm4.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ cc y.tab.c lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
		./a.out
Enter the declaration :
		int a;
		valid declaration
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
		./a.out
Enter the declaration :
		in a;
		Invalid declaration
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
		./a.out
Enter the declaration :
		abc;
		Invalid declaration
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
		./a.out
Enter the declaration :
		int a,b,c;
		valid declaration
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
		./a.out
Enter the declaration :
		int a12;
		valid declaration
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
		./a.out
Enter the declaration :
		int 11abc;
		Invalid declaration
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ gedit
		pgm4.l
		^[[A^C
   (base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		   ./a.out
   Enter the declaration :
		   a12b
		   Invalid declaration
		   5)write a YACC program to recognize nested if statements and display
		  the levels of nesting.
		%{
#include<stdio.h>
#include<stdlib.h> //for exit call
			int count=0;
			%
		}
		%token IF S relop ID Number NL
		%%
stmt : ifstmt NL {printf("Levels of nested if =%d\n",count); exit(0);}
		;
ifstmt : IF '(' cond ')' '{' ifstmt '}' {count++;}
		| S
		;
cond: term relop term
		;
term: ID
		|Number
		;
		%%
		int yyerror(char *msg) {
			printf("Invalid statement\n");
			exit(0);
		}
		void main() {
			printf("Enter the statement \n");
			yyparse();
		}
		gedit pgm5.l
		%{
#include "y.tab.h"
			%
		}
		%%
		"if" {return IF;}
		[sS][0-9]* {return S;}
		"<"|"<="|">="|">"|"=="|"!=" {return relop;}
		[a-zA-Z][a-zA-Z0-9]* {return ID;}
		[0-9]+ {return Number;}
		\n {return NL;}
		. {return yytext[0];}
		%%
Output:
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$ yacc
		-d pgm5.y
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$ lex
		pgm5.l
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$ cc
		y.tab.c lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
		Enter the statement
		if(a>12) {
		s1
	}
	Levels of nested if =1
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
		Enter the statement
		if(a>b) {
			if(b>23) {
					s23
				}
			}
		Levels of nested if =2
                     (base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		                     ./a.out
		                     Enter the statement
		                     if(a>v
			                        Invalid statement
			                        6)Write a YACC program to check the syntax of a simple expression
			                     involving the arithmetic operator +,-.*,/
			                     (cover the expression with different types of parentheses )
			                     gedit pgm6.y
			%{
#include<stdio.h>
#include<stdlib.h>
			%
		}
	%left '+' '-'
	%left '*' '/'
	%token NL ID Digit
	%%
STMT:Expr NL {printf("Valid Expression\n"); exit(0);}
		;
Expr:Expr '+' Expr
		|Expr '-' Expr
		|Expr '*' Expr
		|Expr '/' Expr
		|'(' Expr ')'
		|'[' Expr ']'
		|'{' Expr '}'
		|ID
		|Digit
		;
		%%
		int yyerror(char *msg) {
			printf("Invalid Expression\n");
			exit(0);
		}
		void main() {
			printf("Enter the Expression:\n");
			yyparse();
		}
		gedit pgm6.l
		%{
#include "y.tab.h"
			%
		}
		%%
		\n {return NL;}
		[a-zA-Z][a-zA-Z0-9]* {return ID;}
		[0-9]+ {return Digit;}
		. {return yytext[0];}
		%%
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$ gedit
		pgm6.y
		^C
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$ yacc
		-d pgm6.y
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$ lex
		pgm6.l
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$ cc
		y.tab.c lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
Enter the Expression:
		4+4
		Valid Expression
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
Enter the Expression:
		5+3+3+3+3+2
		Valid Expression
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
Enter the Expression:
		4+33+
		Invalid Expression
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
Enter the Expression:
		5+g
		Valid Expression
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
Enter the Expression:
		A+()
		Invalid Expression
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
Enter the Expression:
		a+b+(a)
		Valid Expression
(base) student@NMAMIT-CSE-CSL06-PC-22:~/Desktop/golibaje/PART_B$
		./a.out
Enter the Expression:
		{a}
		Valid Expression
		7)Write a YACC program to evaluate the arithmetic expression
		involving operators +,-,*,/ (cover the expression with different types
		                             of parentheses )
		gedit pgm7.y
		%{
#include <stdio.h>
#include <stdlib.h>
			%
		}
		%left '+' '-'
		%left '*' '/'
		%token NL Digit
		%%
STMT:
		Expr NL {printf("Result=%d\n",$1); exit(0);}
		;
Expr:
		Expr '+' Expr {$$=$1+$3;}
		|Expr '-' Expr {$$=$1-$3;}
		|Expr '*' Expr {$$=$1*$3;}
		|Expr '/' Expr {
			if($3==0) {
				printf("divide by zero error\n") ;
				exit(0);
			}
			else {
				$$=$1/$3;
			}
		}
		|'(' Expr ')' {$$=$2;}
		|'[' Expr ']' {$$=$2;}
		|'{' Expr '}' {$$=$2;}
		|Digit {$$=$1;}
		;
		%%
		int yyerror(char *msg) {
			printf("Invalid Expression\n");
			exit(0);
		}
		void main() {
			printf("Enter the Expression:\n");
			yyparse();
		}
		gedit pgm7.l
		%{
#include "y.tab.h"
			extern int yylval;
			%
		}
		%%
		[0-9]+ {yylval=atoi(yytext); return Digit;}
		\n {return NL;}
		. {return yytext[0];}
		%%
Output:
base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ yacc -d
		pgm7.y
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ lex pgm7.l
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ cc y.tab.c
		lex.yy.c -ll
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
Enter the Expression:
		5+3
		Result=8
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
Enter the Expression:
		a+v
		Invalid Expression
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
Enter the Expression:
		5+4+2/2+3
		Result=13
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
Enter the Expression:
		(2+3)*2/3
		Result=3
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$ ./a.out
Enter the Expression:
		4+
		Invalid Expression
(base) student@NMAMIT-CSE-CSL06-PC-22:
		~/Desktop/golibaje/PART_B$
